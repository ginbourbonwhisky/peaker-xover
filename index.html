<!DOCTYPE html>
<html lang="ja">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Speaker Xover (2-way)</title>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;margin:16px}
  .row{display:flex;gap:12px;flex-wrap:wrap;align-items:flex-end;margin:8px 0}
  label{display:flex;flex-direction:column;font-size:12px}
  input,select,button{padding:8px;border:1px solid #ccc;border-radius:6px}
  fieldset{border:1px solid #ddd;border-radius:8px;padding:8px}
  legend{font-size:12px;color:#666}
  .row-inline{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
  fieldset.toggles{display:flex;gap:14px;align-items:center;margin:0}
  fieldset.toggles label{display:flex;flex-direction:row;align-items:center;gap:6px}
  #results{white-space:pre-wrap;font-family:ui-monospace,Menlo,monospace;font-size:12px;margin-top:12px}
  canvas{background:#fff;border-radius:8px;max-width:980px}
</style>
<h1>スピーカーネットワーク設計（2‑way）</h1>
<div class="row">
  <label>システム
    <select id="system">
      <option value="2way" selected>2-way</option>
      <option value="3way">3-way（UIのみ/次版で計算）</option>
    </select>
  </label>
  <label>SPL基準
    <select id="spl-basis">
      <option value="minSensitivity" selected>最小能率を基準</option>
      <option value="targetSystemSPL">システム目標SPLを入力</option>
    </select>
  </label>
  <label id="target-wrap">目標SPL (dB/2.83V/1m)
    <input id="target-spl" type="number" step="0.1" placeholder="例: 90.0">
  </label>
  <label>クロス周波数(Hz)
    <input id="fc1" type="number" value="1800">
  </label>
</div>

<h3>LP（Woofer）</h3>
<div class="row">
  <label>Ω<input id="wz" type="number" value="8"></label>
  <label>dB<input id="wspl" type="number" value="90" step="0.1"></label>
  <label>特性
    <select id="wtype"><option>LR2</option><option>LR4</option><option>Butterworth</option><option>Bessel</option></select>
  </label>
  <label>Zobel（Re/Le自動推定）
    <select id="wzobel"><option value="on" selected>ON</option><option value="off">OFF</option></select>
  </label>
</div>

<h3>HP（Tweeter）</h3>
<div class="row">
  <label>Ω<input id="tz" type="number" value="8"></label>
  <label>dB<input id="tspl" type="number" value="98" step="0.1"></label>
  <label>特性
    <select id="ttype"><option>LR2</option><option selected>LR4</option><option>Butterworth</option><option>Bessel</option></select>
  </label>
  <label>ツイーター減衰（自動・名目Z維持）
    <select id="tlpad"><option value="auto" selected>自動</option><option value="off">OFF</option></select>
  </label>
</div>

<div class="row row-inline">
  <button id="calc">計算する</button>
  <button id="export-markdown">Markdownエクスポート</button>
  <button id="load-testcase">テストケース読み込み</button>
  <fieldset class="toggles">
    <legend>グラフ表示</legend>
    <label><input type="checkbox" id="show-woo" checked> Woofer</label>
    <label><input type="checkbox" id="show-twe" checked> Tweeter</label>
    <label><input type="checkbox" id="show-sum" checked> Sum</label>
    <label><input type="checkbox" id="show-snapped" checked> スナップ後（実用値）</label>
    <label><input type="checkbox" id="show-delta"> 差分（理想−スナップ後）</label>
    <label><input type="checkbox" id="show-acoustic"> 音響合成</label>
    <label><input type="checkbox" id="show-imp" checked> インピーダンスZ</label>
  </fieldset>
</div>

<canvas id="plot" height="90"></canvas>
<div id="results"></div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
  const el=id=>document.getElementById(id);
  // タクマン推奨抵抗値リスト（ユーザー提供の完全版）
  const TAKMAN_RESISTORS = [
    0.1, 0.12, 0.15, 0.18, 0.22, 0.27, 0.33, 0.39, 0.47, 0.56, 0.68, 0.82,
    1.0, 1.2, 1.5, 1.8, 2.2, 2.7, 3.3, 3.9, 4.7, 5.6, 6.8, 8.2,
    10, 12, 15, 18, 22, 27, 33, 39, 47, 56, 68, 82,
    100, 120, 150, 180, 220, 270, 330, 390, 470, 560, 680, 820,
    1000, 1200, 1500, 1800, 2200, 2700, 3300, 3900, 4700, 5600, 6800, 8200,
    10000, 12000, 15000, 18000, 22000, 27000, 33000, 39000, 47000, 56000, 68000, 82000,
    100000, 120000, 150000, 180000, 220000, 270000, 330000, 390000, 470000, 560000, 680000, 820000
  ];
  
  function dbToRatio(db){return Math.pow(10,db/20)}
  function ratioToDb(r){return 20*Math.log10(Math.max(r,1e-12))}
  function lpad(z,att){const A=dbToRatio(att);if(A<=1)return{Rs:0,Rp:Infinity,Zin:z,A:1};const K=A;const Rs=z*(1-1/K);const Rp=z/(K-1);const Zin=Rs+1/(1/Rp+1/z);return{Rs,Rp,Zin,A}}
  
  // 抵抗スナップ機能（単一・直列・並列組合せ）
  function snapResistor(target, list = TAKMAN_RESISTORS) {
    let best = list[0];
    let bestErr = Math.abs(target - best);
    for (let r of list) {
      const err = Math.abs(target - r);
      if (err < bestErr) { best = r; bestErr = err; }
    }
    return { value: best, error: bestErr, errorPercent: (bestErr / target) * 100 };
  }

  function findOptimalResistorCombination(target, list = TAKMAN_RESISTORS) {
    let best = { type: 'single', value: target, error: Infinity, combination: null };
    
    // 単一抵抗での最適値
    const single = snapResistor(target, list);
    if (single.errorPercent < 5) { // 5%以内なら単一抵抗を推奨
      return { type: 'single', value: single.value, error: single.error, combination: null };
    }
    
    // 直列組合せ探索
    for (let r1 of list) {
      for (let r2 of list) {
        const series = r1 + r2;
        const err = Math.abs(target - series);
        if (err < best.error) {
          best = { type: 'series', value: series, error: err, combination: [r1, r2] };
        }
      }
    }
    
    // 並列組合せ探索
    for (let r1 of list) {
      for (let r2 of list) {
        if (r1 === 0 || r2 === 0) continue;
        const parallel = (r1 * r2) / (r1 + r2);
        const err = Math.abs(target - parallel);
        if (err < best.error) {
          best = { type: 'parallel', value: parallel, error: err, combination: [r1, r2] };
        }
      }
    }
    
    return best;
  }
  
  // 抵抗組合せの表示フォーマット
  function formatResistorCombination(optimal) {
    if (optimal.type === 'single') {
      return `${(Math.round(optimal.value * 100) / 100).toFixed(2)}Ω (単一)`;
    } else if (optimal.type === 'series') {
      return `${(Math.round(optimal.value * 100) / 100).toFixed(2)}Ω (${optimal.combination[0]}Ω + ${optimal.combination[1]}Ω 直列)`;
    } else if (optimal.type === 'parallel') {
      return `${(Math.round(optimal.value * 100) / 100).toFixed(2)}Ω (${optimal.combination[0]}Ω || ${optimal.combination[1]}Ω 並列)`;
    }
    return `${(Math.round(optimal.value * 100) / 100).toFixed(2)}Ω`;
  }
  
  function estimateZobel(zNom,fc){const Re=0.8*zNom;const Le=zNom/(2*Math.PI*fc*5);const Rz=Re;const Cz=Le/(Rz*Rz);return{Re,Le,Rz,Cz}}
  // 複素数クラス（簡易版）
  class Complex {
    constructor(real, imag) {
      this.real = real || 0;
      this.imag = imag || 0;
    }
    
    add(other) {
      if (typeof other === 'number') {
        return new Complex(this.real + other, this.imag);
      }
      return new Complex(this.real + other.real, this.imag + other.imag);
    }
    
    multiply(other) {
      if (typeof other === 'number') {
        return new Complex(this.real * other, this.imag * other);
      }
      return new Complex(
        this.real * other.real - this.imag * other.imag,
        this.real * other.imag + this.imag * other.real
      );
    }
    
    divide(other) {
      if (typeof other === 'number') {
        return new Complex(this.real / other, this.imag / other);
      }
      const denom = other.real * other.real + other.imag * other.imag;
      if (denom === 0) return new Complex(0, 0);
      return new Complex(
        (this.real * other.real + this.imag * other.imag) / denom,
        (this.imag * other.real - this.real * other.imag) / denom
      );
    }
    
    phase() {
      return Math.atan2(this.imag, this.real);
    }
    
    magnitude() {
      return Math.sqrt(this.real * this.real + this.imag * this.imag);
    }
  }
  
  // 伝達関数の計算
  function getTransferFunction(type, s, isHP) {
    if (type === 'LR2') {
      const den = s.multiply(s).add(s.multiply(2)).add(1); // (s+1)²
      return isHP ? s.multiply(s).divide(den) : new Complex(1, 0).divide(den);
    } else if (type === 'LR4') {
      const sqrt2 = Math.sqrt(2);
      const den2 = s.multiply(s).add(s.multiply(sqrt2)).add(1); // s²+√2s+1
      const den = den2.multiply(den2); // (s²+√2s+1)²
      return isHP ? s.multiply(s).multiply(s).multiply(s).divide(den) : new Complex(1, 0).divide(den);
    } else if (type === 'Butterworth') {
      const sqrt2 = Math.sqrt(2);
      const den = s.multiply(s).add(s.multiply(sqrt2)).add(1); // s²+√2s+1
      return isHP ? s.multiply(s).divide(den) : new Complex(1, 0).divide(den);
    } else if (type === 'Bessel') {
      const den = s.multiply(s).add(s.multiply(3)).add(3); // s²+3s+3
      return isHP ? s.multiply(s).divide(den) : new Complex(3, 0).divide(den);
    }
    return new Complex(1, 0);
  }
  
  // 周波数特性のリップル誤差評価
  function evaluateRippleError(fc, wooferType, tweeterType, attDb, dxM, polarityRad) {
    const f_lo = fc / Math.sqrt(2);
    const f_hi = fc * Math.sqrt(2);
    const n = 21; // サンプル数
    
    let err = 0;
    for (let i = 0; i < n; i++) {
      const t = i / (n - 1);
      const f = Math.exp(Math.log(f_lo) * (1 - t) + Math.log(f_hi) * t);
      
      const s = new Complex(0, f / fc);
      const H_LP = getTransferFunction(wooferType, s, false);
      const H_HP = getTransferFunction(tweeterType, s, true);
      
      // L-pad減衰
      const K = Math.pow(10, attDb / 20.0);
      const G_pad = 1.0 / K;
      
      // 物理オフセット
      const C_SOUND = 343.0;
      const phi_delay = 2 * Math.PI * f * dxM / C_SOUND;
      const G_delay = new Complex(Math.cos(phi_delay), Math.sin(phi_delay));
      
      const A_HP = H_HP.multiply(G_pad).multiply(G_delay);
      const A_LP = H_LP;
      
      // 極性を考慮した合成
      const polarity = new Complex(Math.cos(polarityRad), Math.sin(polarityRad));
      const H_sum = A_LP.add(A_HP.multiply(polarity));
      
      // dB偏差の二乗
      const magDb = 20 * Math.log10(H_sum.magnitude());
      err += magDb * magDb;
    }
    
    return err / n;
  }
  
  // 高度な極性判定（伝達関数ベース、周波数特性評価）
  function autoPolarity(wooferType, tweeterType, fc, attDb = 0, dxM = 0) {
    // 伝達関数ベースの位相計算
    const s = new Complex(0, 1); // s = j (正規化周波数)
    
    const H_LP = getTransferFunction(wooferType, s, false); // LP
    const H_HP = getTransferFunction(tweeterType, s, true);  // HP
    
    // L-pad減衰（位相0°のゲイン）
    const K = Math.pow(10, attDb / 20.0);
    const G_pad = 1.0 / K;
    
    // 物理オフセット（到達遅延）
    const C_SOUND = 343.0; // m/s
    const phi_delay = 2 * Math.PI * fc * dxM / C_SOUND;
    const G_delay = new Complex(Math.cos(phi_delay), Math.sin(phi_delay));
    
    // 合成応答
    const A_HP = H_HP.multiply(G_pad).multiply(G_delay);
    const A_LP = H_LP;
    
    // クロス周波数での位相差
    const phaseDiff = Math.abs(A_HP.phase() - A_LP.phase()) * 180 / Math.PI;
    
    // 周波数特性のフラット性評価
    const score0 = evaluateRippleError(fc, wooferType, tweeterType, attDb, dxM, 0);
    const score180 = evaluateRippleError(fc, wooferType, tweeterType, attDb, dxM, Math.PI);
    
    const shouldInvert = score180 < score0;
    const reason = shouldInvert ? 
      `周波数特性評価で反転が優位 (0°: ${score0.toFixed(2)}, 180°: ${score180.toFixed(2)})` :
      `周波数特性評価で同相が優位 (0°: ${score0.toFixed(2)}, 180°: ${score180.toFixed(2)})`;
    
    return {
      polarity: shouldInvert ? 'invert' : 'normal',
      phaseDiff: phaseDiff,
      wooferPhase: A_LP.phase() * 180 / Math.PI,
      tweeterPhase: A_HP.phase() * 180 / Math.PI,
      reason: reason,
      score0: score0,
      score180: score180
    };
  }
  
  // フィルタの位相特性を計算（理論値ベース）
  function getFilterPhase(type, fc, isHP) {
    // クロス周波数での位相を計算（理論値）
    if (type === 'LR2') {
      return isHP ? -90 : 90;  // HP: -90°, LP: +90° → 180°差
    } else if (type === 'LR4') {
      return isHP ? 180 : 180; // HP: 180°, LP: 180° → 0°差（同相）
    } else if (type === 'Butterworth') {
      return isHP ? -90 : 90;   // HP: -90°, LP: +90° → 180°差
    } else if (type === 'Bessel') {
      return isHP ? -60 : 120;  // HP: -60°, LP: +120° → 180°差
    }
    return 0;
  }
  function fmtOhm(x){return x===Infinity?'∞':(Math.round(x*100)/100).toFixed(2)+' Ω'}
  function fmtCap(c){return (c*1e6).toFixed(3)+' µF'}
  function fmtInd(l){return (l*1e3).toFixed(3)+' mH'}
  // フィルタ特性の正確な係数（教科書値）
  function getFilterCoeffs(type){
    if(type==='LR2') return { Q:0.5, order:2, note:'LR2' };
    if(type==='LR4') return { Q:0.5, order:4, note:'LR4' };
    if(type==='Butterworth') return { Q:0.707, order:2, note:'Butterworth 2次' };
    if(type==='Bessel') return { Q:0.577, order:2, note:'Bessel 2次' };
    return { Q:0.5, order:2, note:'デフォルト' };
  }
  // 簡易音響モデル（ドライバの帯域外特性）
  function driverAcousticResponse(f, driverType) {
    if (driverType === 'woofer') {
      // ウーファー: 高域ロールオフ + 低域共振
      const f_high = 3000; // 高域ロールオフ開始周波数
      const f_low = 50;    // 低域共振周波数
      const Q_low = 0.7;   // 低域共振Q値
      
      // 高域ロールオフ（2次）
      const highRolloff = f > f_high ? 1 / Math.sqrt(1 + Math.pow(f / f_high, 4)) : 1;
      
      // 低域共振（2次）
      const lowResonance = f < f_low ? 1 / Math.sqrt(1 + Math.pow(f_low / f, 4) + 2 * Math.pow(f_low / f, 2) * (2 * Q_low * Q_low - 1)) : 1;
      
      return highRolloff * lowResonance;
    } else if (driverType === 'tweeter') {
      // ツイーター: 低域ロールオフ + 高域共振
      const f_low = 800;   // 低域ロールオフ開始周波数
      const f_high = 20000; // 高域共振周波数
      const Q_high = 0.5;   // 高域共振Q値
      
      // 低域ロールオフ（2次）
      const lowRolloff = f < f_low ? 1 / Math.sqrt(1 + Math.pow(f_low / f, 4)) : 1;
      
      // 高域共振（2次）
      const highResonance = f > f_high ? 1 / Math.sqrt(1 + Math.pow(f / f_high, 4) + 2 * Math.pow(f / f_high, 2) * (2 * Q_high * Q_high - 1)) : 1;
      
      return lowRolloff * highResonance;
    }
    return 1; // デフォルト
  }
  
  function magLP(type,f,fc){
    const x=f/fc;
    const coeffs = getFilterCoeffs(type);
    if(coeffs.order===2){
      const Q = coeffs.Q;
      return 1/Math.sqrt(1 + Math.pow(x,4) + 2*Math.pow(x,2)*(2*Q*Q-1));
    }
    if(coeffs.order===4){
      // LR4 = LR2 × LR2
      const lr2 = 1/Math.sqrt(1 + Math.pow(x,4));
      return lr2 * lr2;
    }
    return 1/Math.sqrt(1+x*x);
  }
  function magHP(type,f,fc){
    const x=fc/f;
    const coeffs = getFilterCoeffs(type);
    if(coeffs.order===2){
      const Q = coeffs.Q;
      return 1/Math.sqrt(1 + Math.pow(x,4) + 2*Math.pow(x,2)*(2*Q*Q-1));
    }
    if(coeffs.order===4){
      const lr2 = 1/Math.sqrt(1 + Math.pow(x,4));
      return lr2 * lr2;
    }
    return 1/Math.sqrt(1+x*x);
  }
  
  // 音響合成（電気フィルタ + ドライバ音響特性）
  function acousticResponseLP(type, f, fc) {
    const electrical = magLP(type, f, fc);
    const acoustic = driverAcousticResponse(f, 'woofer');
    return electrical * acoustic;
  }
  
  function acousticResponseHP(type, f, fc) {
    const electrical = magHP(type, f, fc);
    const acoustic = driverAcousticResponse(f, 'tweeter');
    return electrical * acoustic;
  }
  
  // 警告・バリデーション機能
  function validateDesign(wooferType, tweeterType, fc, wspl, tspl, systemSPL, needAtt) {
    const warnings = [];
    
    // 1. クロス周波数の妥当性チェック
    if (fc < 500) {
      warnings.push('クロス周波数が低すぎます（500Hz未満）。ツイーターの低域限界を考慮してください。');
    } else if (fc > 5000) {
      warnings.push('クロス周波数が高すぎます（5kHz超）。ウーファーの高域限界を考慮してください。');
    }
    
    // 2. SPL差のチェック
    const splDiff = Math.abs(tspl - wspl);
    if (splDiff > 10) {
      warnings.push(`SPL差が大きすぎます（${splDiff.toFixed(1)}dB）。L-pad減衰が大きくなり効率が低下します。`);
    }
    
    // 3. L-pad減衰のチェック
    if (needAtt > 12) {
      warnings.push(`L-pad減衰が大きすぎます（${needAtt.toFixed(1)}dB）。ツイーターの効率が大幅に低下します。`);
    } else if (needAtt > 6) {
      warnings.push(`L-pad減衰が大きめです（${needAtt.toFixed(1)}dB）。ツイーターの効率低下に注意してください。`);
    }
    
    // 4. フィルタ特性の組み合わせチェック
    if (wooferType === 'Butterworth' && tweeterType === 'Butterworth') {
      warnings.push('Butterworth同士の組み合わせは位相特性によりディップやピークが生じやすいです。測定での調整を推奨します。');
    }
    
    // 5. システムSPLの妥当性チェック
    if (systemSPL < 80) {
      warnings.push('システムSPLが低めです（80dB未満）。十分な音量が得られない可能性があります。');
    } else if (systemSPL > 100) {
      warnings.push('システムSPLが高めです（100dB超）。実現可能性を確認してください。');
    }
    
    // 6. インピーダンスのチェック
    // 注：現在は8Ω固定だが、将来的に可変になった場合の準備
    
    return warnings;
  }
  function genFreq(){const arr=[];for(let p=Math.log10(20);p<=Math.log10(40000);p+=0.02){arr.push(10**p)}return arr}
  function wiringForHP(type){if(type==='LR4')return['C1(series)','L1(shunt)','C2(series)','L2(shunt)'];return['C(series)','L(shunt)']}
  function wiringForLP(type){if(type==='LR4')return['L1(series)','C1(shunt)','L2(series)','C2(shunt)'];return['L(series)','C(shunt)']}
  function formatWiringLine(prefix,parts,tail=''){return`${prefix} ${parts.map(p=>p).join(' → ')}${tail}`}
  let chart;
  function draw2Way(freq,series,toggles){
    const ctx=el('plot').getContext('2d');
    if(chart)chart.destroy();
    const ds=[];
    if(toggles.showWoo)ds.push({label:'Woofer',data:series.wIdeal,borderColor:'#d33',pointRadius:0});
    if(toggles.showTwe)ds.push({label:'Tweeter',data:series.tIdeal,borderColor:'#06c',pointRadius:0});
    if(toggles.showSum)ds.push({label:'Sum',data:series.sumIdeal,borderColor:'#000',pointRadius:0});
    if(toggles.showSnapped){
      if(toggles.showWoo)ds.push({label:'Woofer（スナップ後）',data:series.wSnap,borderColor:'#f88',pointRadius:0,borderDash:[4,2]});
      if(toggles.showTwe)ds.push({label:'Tweeter（スナップ後）',data:series.tSnap,borderColor:'#8af',pointRadius:0,borderDash:[4,2]});
      if(toggles.showSum)ds.push({label:'Sum（スナップ後）',data:series.sumSnap,borderColor:'#666',pointRadius:0,borderDash:[4,2]});
    }
    if(toggles.showDelta){ ds.push({label:'差分（理想−スナップ後）',data:series.delta,borderColor:'#0b6',pointRadius:0,borderDash:[2,4]}); }
    if(toggles.showAcoustic){
      if(toggles.showWoo)ds.push({label:'Woofer（音響合成）',data:series.wAcoustic,borderColor:'#a33',pointRadius:0,borderDash:[8,4]});
      if(toggles.showTwe)ds.push({label:'Tweeter（音響合成）',data:series.tAcoustic,borderColor:'#33a',pointRadius:0,borderDash:[8,4]});
    }
    chart=new Chart(ctx,{
      type:'line',
      data:{ labels:freq, datasets:ds },
      options:{
        responsive:true,
        interaction:{ mode:'nearest', intersect:false },
        plugins:{ legend:{ position:'bottom' } },
        scales:{
          x:{ type:'logarithmic', min:20, max:40000, ticks:{ callback:function(v){ return v; } }, title:{ display:true, text:'Hz' } },
          y:{ title:{ display:true, text:'dB' }, min:-20, max:20 }
        }
      }
    });
  }
  function run(){
    const system=el('system').value;
    const wz=+el('wz').value||8, wspl=+el('wspl').value||90, wtype=el('wtype').value;
    const tz=+el('tz').value||8, tspl=+el('tspl').value||98, ttype=el('ttype').value;
    const fc=+el('fc1').value||1800;
    const basis=el('spl-basis').value;
    let systemSPL=Math.min(wspl,tspl);
    let basisText='最小能率';
    if(basis==='targetSystemSPL'){
      const t=+el('target-spl').value; if(t>0){ systemSPL=Math.min(t,systemSPL); basisText=`手動入力（${t.toFixed(1)} dB）`; }
    }
    const lpadMode=el('tlpad').value;
    const needAtt=Math.max(0, tspl-systemSPL);
    const lp=(lpadMode==='auto')? lpad(tz, needAtt) : {Rs:0,Rp:Infinity,Zin:tz,A:1};
    // 古いsnapR関数の呼び出しを新しいfindOptimalResistorCombinationに置き換え
    const RsSnap=(lpadMode==='auto'&&lp.Rs>0)? findOptimalResistorCombination(lp.Rs):null;
    const RpSnap=(lpadMode==='auto'&&isFinite(lp.Rp))? findOptimalResistorCombination(lp.Rp):null;
    const ZinSnap=(lpadMode==='auto'&&RsSnap&&RpSnap)? (RsSnap.value+1/(1/RpSnap.value+1/tz)) : lp.Zin;
    const zbl=(el('wzobel').value==='on')? estimateZobel(wz,fc):null;
    const freq=genFreq();
    const wMag=freq.map(f=> magLP(wtype,f,fc));
    const tMagIdeal=freq.map(f=> magHP(ttype,f,fc));
    
    // 音響合成（電気フィルタ + ドライバ音響特性）
    const wAcousticMag=freq.map(f=> acousticResponseLP(wtype,f,fc));
    const tAcousticMag=freq.map(f=> acousticResponseHP(ttype,f,fc));
    
    // L-pad減衰はdB側で適用（二重適用防止のため振幅には掛けない）
    const tMag=tMagIdeal;
    const wIdealDb=wMag.map(m=> ratioToDb(m) + (wspl-systemSPL));
    const tIdealDb=tMagIdeal.map(m=> ratioToDb(m) + (tspl-systemSPL));
    const tSnapDb=tMag.map(m=> ratioToDb(m) + (tspl-systemSPL) - (lpadMode==='auto'? needAtt:0));
    
    // 音響合成のdB値
    const wAcousticDb=wAcousticMag.map(m=> ratioToDb(m) + (wspl-systemSPL));
    const tAcousticDb=tAcousticMag.map(m=> ratioToDb(m) + (tspl-systemSPL) - (lpadMode==='auto'? needAtt:0));
    const polarityInfo = autoPolarity(wtype, ttype, fc, lpadMode==='auto'? needAtt:0, 0);
    const invert = (polarityInfo.polarity === 'invert');
    function sumDb(aDb,bDb,inv){ const a=dbToRatio(aDb), b=dbToRatio(bDb)*(inv?-1:1); const mag=Math.sqrt(Math.max(0,a*a+b*b)); return ratioToDb(mag); }
    const sumIdealDb=freq.map((_,i)=> sumDb(wIdealDb[i], tIdealDb[i], invert));
    const sumSnapDb=freq.map((_,i)=> sumDb(wIdealDb[i], tSnapDb[i], invert));
    const deltaDb=freq.map((_,i)=> sumIdealDb[i]-sumSnapDb[i]);
    draw2Way(freq,{ wIdeal:wIdealDb, tIdeal:tIdealDb, sumIdeal:sumIdealDb, wSnap:wIdealDb, tSnap:tSnapDb, sumSnap:sumSnapDb, delta:deltaDb, wAcoustic:wAcousticDb, tAcoustic:tAcousticDb },{ showWoo:el('show-woo').checked, showTwe:el('show-twe').checked, showSum:el('show-sum').checked, showSnapped:el('show-snapped').checked, showDelta:el('show-delta').checked, showAcoustic:el('show-acoustic').checked });
    const slopeText = s => s==='LR4'? 'LR4（24 dB/oct）': s==='LR2'? 'LR2（12 dB/oct）' : s;
    const lines=[];
    lines.push('---');
    lines.push(`・システム：${system}`);
    lines.push(`・SPL基準: ${basisText}`);
    lines.push(`・目標クロス周波数：${(fc/1000).toFixed(2)} kHz`);
    lines.push(`・HP（Tweeter）：${tz}Ω、能率${tspl.toFixed(1)}dB、特性${slopeText(ttype)}`);
    lines.push(`・LP（Woofer）：${wz}Ω、能率${wspl.toFixed(1)}dB、特性${slopeText(wtype)}`);
    lines.push(`・Zobel（Woofer補正）：${zbl? '使用（ON）':'未使用（OFF）'}`);
    lines.push(`・L-pad（Tweeter減衰）：${lpadMode==='auto'? '約−'+needAtt.toFixed(1)+' dB（定インピ）':'OFF'}`);
    lines.push('---\n');
    
    // 警告・バリデーション
    const warnings = validateDesign(wtype, ttype, fc, wspl, tspl, systemSPL, needAtt);
    if (warnings.length > 0) {
      lines.push('■ 警告・注意事項');
      warnings.forEach(warning => lines.push(`⚠️ ${warning}`));
      lines.push('');
    }
    
    // 自動極性判定（既に計算済み）
    lines.push(`■ 配線順（概略）:   HP（Tweeter） ${slopeText(ttype)}  ｜  LP（Woofer） ${slopeText(wtype)}`);
    lines.push(`極性判定: ${polarityInfo.polarity === 'invert' ? 'ツイーター反転推奨' : '同相推奨'} (${polarityInfo.reason})`);
    lines.push(`位相差: HP ${polarityInfo.tweeterPhase}° / LP ${polarityInfo.wooferPhase}° (差: ${polarityInfo.phaseDiff}°)`);
    
    const hpWire=wiringForHP(ttype); const lpw=wiringForLP(wtype);
    const polarityMark = polarityInfo.polarity === 'invert' ? ' [反転] ※ユニット端子で＋/−を入れ替える' : '';
    lines.push(formatWiringLine('[入力(＋)] → HP：', hpWire, ` → L-pad(Rs→Rp) → Tweeter(＋)${polarityMark}`));
    lines.push(formatWiringLine('           → LP：', lpw, ' → Woofer(＋) ／ Woofer端子＋−間に [Rz−Cz直列] を並列（Zobel）'));
    lines.push('[入力(−)] → Tweeter(−), Woofer(−)\n');
    lines.push('■ L-pad（ツイーター減衰）');
    if (lpadMode==='auto'){
      lines.push(`必要減衰: ${needAtt.toFixed(2)} dB`);
      lines.push(`理論 Rs: ${fmtOhm(lp.Rs)}, Rp: ${fmtOhm(lp.Rp)}, 入力Z: ${fmtOhm(lp.Zin)}`);
      
      // 新しい抵抗スナップ機能を使用
      const RsOptimal = findOptimalResistorCombination(lp.Rs);
      const RpOptimal = findOptimalResistorCombination(lp.Rp);
      
      lines.push(`実用 Rs: ${formatResistorCombination(RsOptimal)}`);
      lines.push(`実用 Rp: ${formatResistorCombination(RpOptimal)}`);
      
      // スナップ後の入力インピーダンスを計算
      const RsSnapped = RsOptimal.value;
      const RpSnapped = RpOptimal.value;
      const ZinSnapped = RsSnapped + 1/(1/RpSnapped + 1/tz);
      lines.push(`スナップ後 入力Z: ${fmtOhm(ZinSnapped)}`);
    } else { lines.push('OFF'); }
    lines.push('');
    lines.push('■ Zobel（Woofer補正）');
    if (zbl){ 
      lines.push(`理論 Rz: ${fmtOhm(zbl.Rz)}`);
      lines.push(`理論 Cz: ${fmtCap(zbl.Cz)}（Re/Le内部推定）`);
      
      // Zobel抵抗の実用値スナップ
      const RzOptimal = findOptimalResistorCombination(zbl.Rz);
      lines.push(`実用 Rz: ${formatResistorCombination(RzOptimal)}`);
      lines.push(`実用 Cz: ${fmtCap(zbl.Cz)}（理論値のまま）`);
    } else { 
      lines.push('未適用'); 
    }
    lines.push('');
    // フィルタ素子の理論値（正確な係数ベース）
    const twoPi = 2*Math.PI;
    function calcFilterComponents(type, z, fc, isHP) {
      const coeffs = getFilterCoeffs(type);
      const omega = twoPi * fc;
      
      if (type === 'LR2') {
        // LR2（2次リンクウィッツ・ライリー）の正確な計算式
        if (isHP) {
          const C1 = 1 / (4 * Math.PI * fc * z);
          const L2 = z / (Math.PI * fc);
          return { C1, L1: undefined, C2: undefined, L2, note: 'LR2（2次）' };
        } else {
          const L1 = z / (Math.PI * fc);
          const C2 = 1 / (4 * Math.PI * fc * z);
          return { L1, C1: undefined, L2: undefined, C2, note: 'LR2（2次）' };
        }
      } else if (type === 'LR4') {
        // LR4（4次リンクウィッツ・ライリー）の正確な計算式
        if (isHP) {
          const C1 = (3 * Math.sqrt(2)) / (16 * Math.PI * fc * z);
          const L1 = (2 * Math.sqrt(2) * z) / (9 * Math.PI * fc);
          const C2 = (3 * Math.sqrt(2)) / (8 * Math.PI * fc * z);
          const L2 = (Math.sqrt(2) * z) / (Math.PI * fc);
          return { C1, L1, C2, L2, note: 'LR4（4次）' };
        } else {
          // LR4のLPは通常使用しないが、理論値として計算
          const L3 = (2 * Math.sqrt(2) * z) / (3 * Math.PI * fc);
          const C3 = (9 * Math.sqrt(2)) / (16 * Math.PI * fc * z);
          const L4 = (Math.sqrt(2) * z) / (3 * Math.PI * fc);
          const C4 = Math.sqrt(2) / (8 * Math.PI * fc * z);
          return { L1: L3, C1: C3, L2: L4, C2: C4, note: 'LR4（4次）' };
        }
      } else if (type === 'Butterworth') {
        // Butterworth 2次の正確な計算式
        if (isHP) {
          const C1 = Math.sqrt(2) / (4 * Math.PI * fc * z);
          const L2 = (Math.sqrt(2) * z) / (2 * Math.PI * fc);
          return { C1, L1: undefined, C2: undefined, L2, note: 'Butterworth 2次' };
        } else {
          const L1 = (Math.sqrt(2) * z) / (2 * Math.PI * fc);
          const C2 = Math.sqrt(2) / (4 * Math.PI * fc * z);
          return { L1, C1: undefined, L2: undefined, C2, note: 'Butterworth 2次' };
        }
      } else if (type === 'Bessel') {
        // Bessel 2次の正確な係数
        if (isHP) {
          const C1 = 0.0912 / (z * fc);
          const L2 = (0.2756 * z) / fc;
          return { C1, L1: undefined, C2: undefined, L2, note: 'Bessel 2次' };
        } else {
          const L1 = (0.2756 * z) / fc;
          const C2 = 0.0912 / (z * fc);
          return { L1, C1: undefined, L2: undefined, C2, note: 'Bessel 2次' };
        }
      }
      return { note: '未対応' };
    }
    
    const hpPartsVals = calcFilterComponents(ttype, tz, fc, true);
    const lpPartsVals = calcFilterComponents(wtype, wz, fc, false);
    
    lines.push('■ HP（Tweeter）素子値（理論）');
    if(hpPartsVals.C1 !== undefined) {
      if(ttype === 'LR2' || ttype === 'Butterworth' || ttype === 'Bessel') {
        lines.push(`C(series)：${fmtCap(hpPartsVals.C1)}`);
      } else {
        lines.push(`C1(series)：${fmtCap(hpPartsVals.C1)}`);
      }
    }
    if(hpPartsVals.L1 !== undefined) {
      if(ttype === 'LR2' || ttype === 'Butterworth' || ttype === 'Bessel') {
        lines.push(`L(shunt)：${fmtInd(hpPartsVals.L1)}`);
      } else {
        lines.push(`L1(shunt)：${fmtInd(hpPartsVals.L1)}`);
      }
    }
    if(hpPartsVals.C2 !== undefined) {
      if(ttype === 'LR2' || ttype === 'Butterworth' || ttype === 'Bessel') {
        lines.push(`C2(series)：${fmtCap(hpPartsVals.C2)}`);
      } else {
        lines.push(`C2(series)：${fmtCap(hpPartsVals.C2)}`);
      }
    }
    if(hpPartsVals.L2 !== undefined) {
      if(ttype === 'LR2' || ttype === 'Butterworth' || ttype === 'Bessel') {
        lines.push(`L(shunt)：${fmtInd(hpPartsVals.L2)}  （${hpPartsVals.note}）`);
      } else {
        lines.push(`L2(shunt)：${fmtInd(hpPartsVals.L2)}  （${hpPartsVals.note}）`);
      }
    }
    lines.push('');
    lines.push('■ LP（Woofer）素子値（理論）');
    if(lpPartsVals.L1 !== undefined) {
      if(wtype === 'LR2' || wtype === 'Butterworth' || wtype === 'Bessel') {
        lines.push(`L(series)：${fmtInd(lpPartsVals.L1)}`);
      } else {
        lines.push(`L1(series)：${fmtInd(lpPartsVals.L1)}`);
      }
    }
    if(lpPartsVals.C1 !== undefined) {
      if(wtype === 'LR2' || wtype === 'Butterworth' || wtype === 'Bessel') {
        lines.push(`C(shunt)：${fmtCap(lpPartsVals.C1)}`);
      } else {
        lines.push(`C1(shunt)：${fmtCap(lpPartsVals.C1)}`);
      }
    }
    if(lpPartsVals.C2 !== undefined) {
      if(wtype === 'LR2' || wtype === 'Butterworth' || wtype === 'Bessel') {
        lines.push(`C(shunt)：${fmtCap(lpPartsVals.C2)}`);
      } else {
        lines.push(`C2(shunt)：${fmtCap(lpPartsVals.C2)}`);
      }
    }
    if(lpPartsVals.L2 !== undefined) {
      if(wtype === 'LR2' || wtype === 'Butterworth' || wtype === 'Bessel') {
        lines.push(`L2(series)：${fmtInd(lpPartsVals.L2)}  （${lpPartsVals.note}）`);
      } else {
        lines.push(`L2(series)：${fmtInd(lpPartsVals.L2)}  （${lpPartsVals.note}）`);
      }
    }
    el('results').textContent = lines.join('\n');
  }
  ['show-woo','show-twe','show-sum','show-snapped','show-delta','show-acoustic','show-imp'].forEach(function(id){ el(id).addEventListener('change', run); });
  el('calc').addEventListener('click', run);
  
  // Markdownエクスポート機能
  el('export-markdown').addEventListener('click', function() {
    const results = el('results').textContent;
    const timestamp = new Date().toLocaleString('ja-JP');
    
    // 結果を設計条件と計算結果に分割
    const parts = results.split('---');
    const designConditions = parts[0] || '';
    const calculationResults = parts.slice(1).join('---') || results;
    
    // 設計条件を整理（システム情報を抽出）
    const allLines = results.split('\n');
    const systemInfo = allLines.filter(line => 
      line.includes('システム：') || 
      line.includes('SPL基準:') || 
      line.includes('目標クロス周波数：') || 
      line.includes('HP（Tweeter）：') || 
      line.includes('LP（Woofer）：') || 
      line.includes('Zobel（Woofer補正）：') || 
      line.includes('L-pad（Tweeter減衰）：')
    );
    
    // 計算結果から設計条件を除去
    const cleanCalculationResults = calculationResults.split('\n').filter(line => 
      !line.includes('システム：') && 
      !line.includes('SPL基準:') && 
      !line.includes('目標クロス周波数：') && 
      !line.includes('HP（Tweeter）：') && 
      !line.includes('LP（Woofer）：') && 
      !line.includes('Zobel（Woofer補正）：') && 
      !line.includes('L-pad（Tweeter減衰）：')
    ).join('\n');
    
    const markdown = `# スピーカーネットワーク設計結果

**生成日時:** ${timestamp}

## 設計条件
${systemInfo.join('\n')}

## 計算結果
${cleanCalculationResults}

---
*この結果は Speaker Network Calculator で生成されました*
*URL: ${window.location.href}*`;

    // ファイルダウンロード
    const blob = new Blob([markdown], { type: 'text/markdown;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `speaker-network-${Date.now()}.md`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  });
  
  // テストケース読み込み機能
  el('load-testcase').addEventListener('click', function() {
    // ユーザー提供のテストケース: 2-way, Woofer 8Ω/90dB, Tweeter 8Ω/98dB, Crossover 1800Hz, Tweeter LR4, Woofer LR2
    el('system').value = '2way';
    el('wz').value = '8';
    el('wspl').value = '90';
    el('tz').value = '8';
    el('tspl').value = '98';
    el('fc').value = '1800';
    el('wtype').value = 'LR2';
    el('ttype').value = 'LR4';
    el('spl-basis').value = 'minEfficiency';
    el('target-spl').value = '';
    el('wzobel').value = 'on';
    el('tlpad').value = 'auto';
    
    // 計算を実行
    run();
  });
  
  run();
</script>

<!-- バージョン情報 -->
<div style="text-align: center; margin-top: 20px; padding: 10px; background-color: #f5f5f5; border-radius: 5px; font-size: 12px; color: #666;">
  <strong>Speaker Network Calculator</strong><br>
  バージョン: 2.1.0 (高度な極性判定アルゴリズム実装)<br>
  最終更新: 2025-09-28 10:57<br>
  <a href="https://github.com/ginbourbonwhisky/peaker-xover" target="_blank" style="color: #0066cc;">GitHub Repository</a>
</div>

</html>
