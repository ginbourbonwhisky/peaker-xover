<!DOCTYPE html>
<html lang="ja">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Speaker Xover (2-way)</title>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;margin:16px}
  .row{display:flex;gap:12px;flex-wrap:wrap;align-items:flex-end;margin:8px 0}
  label{display:flex;flex-direction:column;font-size:12px}
  input,select,button{padding:8px;border:1px solid #ccc;border-radius:6px}
  fieldset{border:1px solid #ddd;border-radius:8px;padding:8px}
  legend{font-size:12px;color:#666}
  .row-inline{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
  fieldset.toggles{display:flex;gap:14px;align-items:center;margin:0}
  fieldset.toggles label{display:flex;flex-direction:row;align-items:center;gap:6px}
  #results{white-space:pre-wrap;font-family:ui-monospace,Menlo,monospace;font-size:12px;margin-top:12px}
  canvas{background:#fff;border-radius:8px;max-width:980px}
</style>
<h1>スピーカーネットワーク設計（2‑way）</h1>
<div class="row">
  <label>システム
    <select id="system">
      <option value="2way" selected>2-way</option>
      <option value="3way">3-way（UIのみ/次版で計算）</option>
    </select>
  </label>
  <label>SPL基準
    <select id="spl-basis">
      <option value="minSensitivity" selected>最小能率を基準</option>
      <option value="targetSystemSPL">システム目標SPLを入力</option>
    </select>
  </label>
  <label id="target-wrap">目標SPL (dB/2.83V/1m)
    <input id="target-spl" type="number" step="0.1" placeholder="例: 90.0">
  </label>
  <label>クロス周波数(Hz)
    <input id="fc1" type="number" value="1800">
  </label>
</div>

<h3>LP（Woofer）</h3>
<div class="row">
  <label>Ω<input id="wz" type="number" value="8"></label>
  <label>dB<input id="wspl" type="number" value="90" step="0.1"></label>
  <label>特性
    <select id="wtype"><option>LR2</option><option>LR4</option><option>Butterworth</option><option>Bessel</option></select>
  </label>
  <label>Zobel（Re/Le自動推定）
    <select id="wzobel"><option value="on" selected>ON</option><option value="off">OFF</option></select>
  </label>
</div>

<h3>HP（Tweeter）</h3>
<div class="row">
  <label>Ω<input id="tz" type="number" value="8"></label>
  <label>dB<input id="tspl" type="number" value="98" step="0.1"></label>
  <label>特性
    <select id="ttype"><option>LR2</option><option selected>LR4</option><option>Butterworth</option><option>Bessel</option></select>
  </label>
  <label>ツイーター減衰（自動・名目Z維持）
    <select id="tlpad"><option value="auto" selected>自動</option><option value="off">OFF</option></select>
  </label>
</div>

<div class="row row-inline">
  <button id="calc">計算する</button>
  <button id="export-markdown">Markdownエクスポート</button>
  <button id="load-testcase">テストケース読み込み</button>
  <fieldset class="toggles">
    <legend>グラフ表示</legend>
    <label><input type="checkbox" id="show-woo" checked> Woofer</label>
    <label><input type="checkbox" id="show-twe" checked> Tweeter</label>
    <label><input type="checkbox" id="show-sum" checked> Sum</label>
    <label><input type="checkbox" id="show-snapped" checked> スナップ後（実用値）</label>
    <label><input type="checkbox" id="show-delta"> 差分（理想−スナップ後）</label>
    <label><input type="checkbox" id="show-imp" checked> インピーダンスZ</label>
  </fieldset>
</div>

<canvas id="plot" height="90"></canvas>
<div id="results"></div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
  const el=id=>document.getElementById(id);
  // タクマン推奨抵抗値リスト（ユーザー提供の完全版）
  const TAKMAN_RESISTORS = [
    0.1, 0.12, 0.15, 0.18, 0.22, 0.27, 0.33, 0.39, 0.47, 0.56, 0.68, 0.82,
    1.0, 1.2, 1.5, 1.8, 2.2, 2.7, 3.3, 3.9, 4.7, 5.6, 6.8, 8.2,
    10, 12, 15, 18, 22, 27, 33, 39, 47, 56, 68, 82,
    100, 120, 150, 180, 220, 270, 330, 390, 470, 560, 680, 820,
    1000, 1200, 1500, 1800, 2200, 2700, 3300, 3900, 4700, 5600, 6800, 8200,
    10000, 12000, 15000, 18000, 22000, 27000, 33000, 39000, 47000, 56000, 68000, 82000,
    100000, 120000, 150000, 180000, 220000, 270000, 330000, 390000, 470000, 560000, 680000, 820000
  ];
  
  function dbToRatio(db){return Math.pow(10,db/20)}
  function ratioToDb(r){return 20*Math.log10(Math.max(r,1e-12))}
  function lpad(z,att){const A=dbToRatio(att);if(A<=1)return{Rs:0,Rp:Infinity,Zin:z,A:1};const K=A;const Rs=z*(1-1/K);const Rp=z/(K-1);const Zin=Rs+1/(1/Rp+1/z);return{Rs,Rp,Zin,A}}
  
  // 抵抗スナップ機能（単一・直列・並列組合せ）
  function snapResistor(target, list = TAKMAN_RESISTORS) {
    let best = list[0];
    let bestErr = Math.abs(target - best);
    for (let r of list) {
      const err = Math.abs(target - r);
      if (err < bestErr) { best = r; bestErr = err; }
    }
    return { value: best, error: bestErr, errorPercent: (bestErr / target) * 100 };
  }

  function findOptimalResistorCombination(target, list = TAKMAN_RESISTORS) {
    let best = { type: 'single', value: target, error: Infinity, combination: null };
    
    // 単一抵抗での最適値
    const single = snapResistor(target, list);
    if (single.errorPercent < 5) { // 5%以内なら単一抵抗を推奨
      return { type: 'single', value: single.value, error: single.error, combination: null };
    }
    
    // 直列組合せ探索
    for (let r1 of list) {
      for (let r2 of list) {
        const series = r1 + r2;
        const err = Math.abs(target - series);
        if (err < best.error) {
          best = { type: 'series', value: series, error: err, combination: [r1, r2] };
        }
      }
    }
    
    // 並列組合せ探索
    for (let r1 of list) {
      for (let r2 of list) {
        if (r1 === 0 || r2 === 0) continue;
        const parallel = (r1 * r2) / (r1 + r2);
        const err = Math.abs(target - parallel);
        if (err < best.error) {
          best = { type: 'parallel', value: parallel, error: err, combination: [r1, r2] };
        }
      }
    }
    
    return best;
  }
  
  // 抵抗組合せの表示フォーマット
  function formatResistorCombination(optimal) {
    if (optimal.type === 'single') {
      return `${optimal.value}Ω (単一)`;
    } else if (optimal.type === 'series') {
      return `${optimal.value}Ω (${optimal.combination[0]}Ω + ${optimal.combination[1]}Ω)`;
    } else if (optimal.type === 'parallel') {
      return `${optimal.value}Ω (${optimal.combination[0]}Ω || ${optimal.combination[1]}Ω)`;
    }
    return `${optimal.value}Ω`;
  }
  
  function estimateZobel(zNom,fc){const Re=0.8*zNom;const Le=zNom/(2*Math.PI*fc*5);const Rz=Re;const Cz=Le/(Rz*Rz);return{Re,Le,Rz,Cz}}
  function autoPol(w,t){const evenW=(w==='LR2'||w==='LR4'||w==='Butterworth');const evenT=(t==='LR2'||t==='LR4'||t==='Butterworth');return (evenW&&evenT)?'invert':'normal'}
  function fmtOhm(x){return x===Infinity?'∞':(Math.round(x*100)/100).toFixed(2)+' Ω'}
  function fmtCap(c){return (c*1e6).toFixed(3)+' µF'}
  function fmtInd(l){return (l*1e3).toFixed(3)+' mH'}
  // フィルタ特性の正確な係数（教科書値）
  function getFilterCoeffs(type){
    if(type==='LR2') return { Q:0.5, order:2, note:'LR2' };
    if(type==='LR4') return { Q:0.5, order:4, note:'LR4' };
    if(type==='Butterworth') return { Q:0.707, order:2, note:'Butterworth 2次' };
    if(type==='Bessel') return { Q:0.577, order:2, note:'Bessel 2次' };
    return { Q:0.5, order:2, note:'デフォルト' };
  }
  function magLP(type,f,fc){
    const x=f/fc;
    const coeffs = getFilterCoeffs(type);
    if(coeffs.order===2){
      const Q = coeffs.Q;
      return 1/Math.sqrt(1 + Math.pow(x,4) + 2*Math.pow(x,2)*(2*Q*Q-1));
    }
    if(coeffs.order===4){
      // LR4 = LR2 × LR2
      const lr2 = 1/Math.sqrt(1 + Math.pow(x,4));
      return lr2 * lr2;
    }
    return 1/Math.sqrt(1+x*x);
  }
  function magHP(type,f,fc){
    const x=fc/f;
    const coeffs = getFilterCoeffs(type);
    if(coeffs.order===2){
      const Q = coeffs.Q;
      return 1/Math.sqrt(1 + Math.pow(x,4) + 2*Math.pow(x,2)*(2*Q*Q-1));
    }
    if(coeffs.order===4){
      const lr2 = 1/Math.sqrt(1 + Math.pow(x,4));
      return lr2 * lr2;
    }
    return 1/Math.sqrt(1+x*x);
  }
  function genFreq(){const arr=[];for(let p=Math.log10(20);p<=Math.log10(40000);p+=0.02){arr.push(10**p)}return arr}
  function wiringForHP(type){if(type==='LR4')return['C1(series)','L1(shunt)','C2(series)','L2(shunt)'];return['C(series)','L(shunt)']}
  function wiringForLP(type){if(type==='LR4')return['L1(series)','C1(shunt)','L2(series)','C2(shunt)'];return['L(series)','C(shunt)']}
  function formatWiringLine(prefix,parts,tail=''){return`${prefix} ${parts.map(p=>p).join(' → ')}${tail}`}
  let chart;
  function draw2Way(freq,series,toggles){
    const ctx=el('plot').getContext('2d');
    if(chart)chart.destroy();
    const ds=[];
    if(toggles.showWoo)ds.push({label:'Woofer',data:series.wIdeal,borderColor:'#d33',pointRadius:0});
    if(toggles.showTwe)ds.push({label:'Tweeter',data:series.tIdeal,borderColor:'#06c',pointRadius:0});
    if(toggles.showSum)ds.push({label:'Sum',data:series.sumIdeal,borderColor:'#000',pointRadius:0});
    if(toggles.showSnapped){
      if(toggles.showWoo)ds.push({label:'Woofer（スナップ後）',data:series.wSnap,borderColor:'#f88',pointRadius:0,borderDash:[4,2]});
      if(toggles.showTwe)ds.push({label:'Tweeter（スナップ後）',data:series.tSnap,borderColor:'#8af',pointRadius:0,borderDash:[4,2]});
      if(toggles.showSum)ds.push({label:'Sum（スナップ後）',data:series.sumSnap,borderColor:'#666',pointRadius:0,borderDash:[4,2]});
    }
    if(toggles.showDelta){ ds.push({label:'差分（理想−スナップ後）',data:series.delta,borderColor:'#0b6',pointRadius:0,borderDash:[2,4]}); }
    chart=new Chart(ctx,{
      type:'line',
      data:{ labels:freq, datasets:ds },
      options:{
        responsive:true,
        interaction:{ mode:'nearest', intersect:false },
        plugins:{ legend:{ position:'bottom' } },
        scales:{
          x:{ type:'logarithmic', min:20, max:40000, ticks:{ callback:function(v){ return v; } }, title:{ display:true, text:'Hz' } },
          y:{ title:{ display:true, text:'dB' }, min:-20, max:20 }
        }
      }
    });
  }
  function run(){
    const system=el('system').value;
    const wz=+el('wz').value||8, wspl=+el('wspl').value||90, wtype=el('wtype').value;
    const tz=+el('tz').value||8, tspl=+el('tspl').value||98, ttype=el('ttype').value;
    const fc=+el('fc1').value||1800;
    const basis=el('spl-basis').value;
    let systemSPL=Math.min(wspl,tspl);
    let basisText='最小能率';
    if(basis==='targetSystemSPL'){
      const t=+el('target-spl').value; if(t>0){ systemSPL=Math.min(t,systemSPL); basisText=`手動入力（${t.toFixed(1)} dB）`; }
    }
    const lpadMode=el('tlpad').value;
    const needAtt=Math.max(0, tspl-systemSPL);
    const lp=(lpadMode==='auto')? lpad(tz, needAtt) : {Rs:0,Rp:Infinity,Zin:tz,A:1};
    // 古いsnapR関数の呼び出しを新しいfindOptimalResistorCombinationに置き換え
    const RsSnap=(lpadMode==='auto'&&lp.Rs>0)? findOptimalResistorCombination(lp.Rs):null;
    const RpSnap=(lpadMode==='auto'&&isFinite(lp.Rp))? findOptimalResistorCombination(lp.Rp):null;
    const ZinSnap=(lpadMode==='auto'&&RsSnap&&RpSnap)? (RsSnap.value+1/(1/RpSnap.value+1/tz)) : lp.Zin;
    const zbl=(el('wzobel').value==='on')? estimateZobel(wz,fc):null;
    const freq=genFreq();
    const wMag=freq.map(f=> magLP(wtype,f,fc));
    const tMagIdeal=freq.map(f=> magHP(ttype,f,fc));
    // L-pad減衰はdB側で適用（二重適用防止のため振幅には掛けない）
    const tMag=tMagIdeal;
    const wIdealDb=wMag.map(m=> ratioToDb(m) + (wspl-systemSPL));
    const tIdealDb=tMagIdeal.map(m=> ratioToDb(m) + (tspl-systemSPL));
    const tSnapDb=tMag.map(m=> ratioToDb(m) + (tspl-systemSPL) - (lpadMode==='auto'? needAtt:0));
    const invert = (autoPol(wtype,ttype)==='invert');
    function sumDb(aDb,bDb,inv){ const a=dbToRatio(aDb), b=dbToRatio(bDb)*(inv?-1:1); const mag=Math.sqrt(Math.max(0,a*a+b*b)); return ratioToDb(mag); }
    const sumIdealDb=freq.map((_,i)=> sumDb(wIdealDb[i], tIdealDb[i], invert));
    const sumSnapDb=freq.map((_,i)=> sumDb(wIdealDb[i], tSnapDb[i], invert));
    const deltaDb=freq.map((_,i)=> sumIdealDb[i]-sumSnapDb[i]);
    draw2Way(freq,{ wIdeal:wIdealDb, tIdeal:tIdealDb, sumIdeal:sumIdealDb, wSnap:wIdealDb, tSnap:tSnapDb, sumSnap:sumSnapDb, delta:deltaDb },{ showWoo:el('show-woo').checked, showTwe:el('show-twe').checked, showSum:el('show-sum').checked, showSnapped:el('show-snapped').checked, showDelta:el('show-delta').checked });
    const slopeText = s => s==='LR4'? 'LR4（24 dB/oct）': s==='LR2'? 'LR2（12 dB/oct）' : s;
    const lines=[];
    lines.push('---');
    lines.push(`・システム：${system}`);
    lines.push(`・SPL基準: ${basisText}`);
    lines.push(`・目標クロス周波数：${(fc/1000).toFixed(2)} kHz`);
    lines.push(`・HP（Tweeter）：${tz}Ω、能率${tspl.toFixed(1)}dB、特性${slopeText(ttype)}`);
    lines.push(`・LP（Woofer）：${wz}Ω、能率${wspl.toFixed(1)}dB、特性${slopeText(wtype)}`);
    lines.push(`・Zobel（Woofer補正）：${zbl? '使用（ON）':'未使用（OFF）'}`);
    lines.push(`・L-pad（Tweeter減衰）：${lpadMode==='auto'? '約−'+needAtt.toFixed(1)+' dB（定インピ）':'OFF'}`);
    lines.push('---\n');
    lines.push(`■ 配線順（概略）:   HP（Tweeter） ${slopeText(ttype)}  ｜  LP（Woofer） ${slopeText(wtype)}`);
    const hpWire=wiringForHP(ttype); const lpw=wiringForLP(wtype);
    lines.push(formatWiringLine('[入力(＋)] → HP：', hpWire, ' → L-pad(Rs→Rp) → Tweeter(＋)'));
    lines.push(formatWiringLine('           → LP：', lpw, ' → Woofer(＋) ／ Woofer端子＋−間に [Rz−Cz直列] を並列（Zobel）'));
    lines.push('[入力(−)] → Tweeter(−), Woofer(−)\n');
    lines.push('■ L-pad（ツイーター減衰）');
    if (lpadMode==='auto'){
      lines.push(`必要減衰: ${needAtt.toFixed(2)} dB`);
      lines.push(`理論 Rs: ${fmtOhm(lp.Rs)}, Rp: ${fmtOhm(lp.Rp)}, 入力Z: ${fmtOhm(lp.Zin)}`);
      
      // 新しい抵抗スナップ機能を使用
      const RsOptimal = findOptimalResistorCombination(lp.Rs);
      const RpOptimal = findOptimalResistorCombination(lp.Rp);
      
      lines.push(`実用 Rs: ${formatResistorCombination(RsOptimal)}`);
      lines.push(`実用 Rp: ${formatResistorCombination(RpOptimal)}`);
      
      // スナップ後の入力インピーダンスを計算
      const RsSnapped = RsOptimal.value;
      const RpSnapped = RpOptimal.value;
      const ZinSnapped = RsSnapped + 1/(1/RpSnapped + 1/tz);
      lines.push(`スナップ後 入力Z: ${fmtOhm(ZinSnapped)}`);
    } else { lines.push('OFF'); }
    lines.push('');
    lines.push('■ Zobel（Woofer補正）');
    if (zbl){ lines.push(`Rz = ${fmtOhm(zbl.Rz)}`); lines.push(`Cz = ${fmtCap(zbl.Cz)}（Re/Le内部推定）`); } else { lines.push('未適用'); }
    lines.push('');
    // フィルタ素子の理論値（正確な係数ベース）
    const twoPi = 2*Math.PI;
    function calcFilterComponents(type, z, fc, isHP) {
      const coeffs = getFilterCoeffs(type);
      const omega = twoPi * fc;
      
      if (type === 'LR2') {
        // LR2（2次リンクウィッツ・ライリー）の正確な計算式
        if (isHP) {
          const C1 = 1 / (4 * Math.PI * fc * z);
          const L2 = z / (Math.PI * fc);
          return { C1, L1: undefined, C2: undefined, L2, note: 'LR2（2次）' };
        } else {
          const L1 = z / (Math.PI * fc);
          const C2 = 1 / (4 * Math.PI * fc * z);
          return { L1, C1: undefined, L2: undefined, C2, note: 'LR2（2次）' };
        }
      } else if (type === 'LR4') {
        // LR4（4次リンクウィッツ・ライリー）の正確な計算式
        if (isHP) {
          const C1 = (3 * Math.sqrt(2)) / (16 * Math.PI * fc * z);
          const L1 = (2 * Math.sqrt(2) * z) / (9 * Math.PI * fc);
          const C2 = (3 * Math.sqrt(2)) / (8 * Math.PI * fc * z);
          const L2 = (Math.sqrt(2) * z) / (Math.PI * fc);
          return { C1, L1, C2, L2, note: 'LR4（4次）' };
        } else {
          // LR4のLPは通常使用しないが、理論値として計算
          const L3 = (2 * Math.sqrt(2) * z) / (3 * Math.PI * fc);
          const C3 = (9 * Math.sqrt(2)) / (16 * Math.PI * fc * z);
          const L4 = (Math.sqrt(2) * z) / (3 * Math.PI * fc);
          const C4 = Math.sqrt(2) / (8 * Math.PI * fc * z);
          return { L1: L3, C1: C3, L2: L4, C2: C4, note: 'LR4（4次）' };
        }
      } else if (type === 'Butterworth') {
        // Butterworth 2次の正確な計算式
        if (isHP) {
          const C1 = Math.sqrt(2) / (4 * Math.PI * fc * z);
          const L2 = (Math.sqrt(2) * z) / (2 * Math.PI * fc);
          return { C1, L1: undefined, C2: undefined, L2, note: 'Butterworth 2次' };
        } else {
          const L1 = (Math.sqrt(2) * z) / (2 * Math.PI * fc);
          const C2 = Math.sqrt(2) / (4 * Math.PI * fc * z);
          return { L1, C1: undefined, L2: undefined, C2, note: 'Butterworth 2次' };
        }
      } else if (type === 'Bessel') {
        // Bessel 2次の正確な係数
        if (isHP) {
          const C1 = 0.0912 / (z * fc);
          const L2 = (0.2756 * z) / fc;
          return { C1, L1: undefined, C2: undefined, L2, note: 'Bessel 2次' };
        } else {
          const L1 = (0.2756 * z) / fc;
          const C2 = 0.0912 / (z * fc);
          return { L1, C1: undefined, L2: undefined, C2, note: 'Bessel 2次' };
        }
      }
      return { note: '未対応' };
    }
    
    const hpPartsVals = calcFilterComponents(ttype, tz, fc, true);
    const lpPartsVals = calcFilterComponents(wtype, wz, fc, false);
    
    lines.push('■ HP（Tweeter）素子値（理論）');
    if(hpPartsVals.C1 !== undefined) {
      if(ttype === 'LR2' || ttype === 'Butterworth' || ttype === 'Bessel') {
        lines.push(`C(series)：${fmtCap(hpPartsVals.C1)}`);
      } else {
        lines.push(`C1(series)：${fmtCap(hpPartsVals.C1)}`);
      }
    }
    if(hpPartsVals.L1 !== undefined) {
      if(ttype === 'LR2' || ttype === 'Butterworth' || ttype === 'Bessel') {
        lines.push(`L(shunt)：${fmtInd(hpPartsVals.L1)}`);
      } else {
        lines.push(`L1(shunt)：${fmtInd(hpPartsVals.L1)}`);
      }
    }
    if(hpPartsVals.C2 !== undefined) {
      if(ttype === 'LR2' || ttype === 'Butterworth' || ttype === 'Bessel') {
        lines.push(`C2(series)：${fmtCap(hpPartsVals.C2)}`);
      } else {
        lines.push(`C2(series)：${fmtCap(hpPartsVals.C2)}`);
      }
    }
    if(hpPartsVals.L2 !== undefined) {
      if(ttype === 'LR2' || ttype === 'Butterworth' || ttype === 'Bessel') {
        lines.push(`L(shunt)：${fmtInd(hpPartsVals.L2)}  （${hpPartsVals.note}）`);
      } else {
        lines.push(`L2(shunt)：${fmtInd(hpPartsVals.L2)}  （${hpPartsVals.note}）`);
      }
    }
    lines.push('');
    lines.push('■ LP（Woofer）素子値（理論）');
    if(lpPartsVals.L1 !== undefined) {
      if(wtype === 'LR2' || wtype === 'Butterworth' || wtype === 'Bessel') {
        lines.push(`L(series)：${fmtInd(lpPartsVals.L1)}`);
      } else {
        lines.push(`L1(series)：${fmtInd(lpPartsVals.L1)}`);
      }
    }
    if(lpPartsVals.C1 !== undefined) {
      if(wtype === 'LR2' || wtype === 'Butterworth' || wtype === 'Bessel') {
        lines.push(`C(shunt)：${fmtCap(lpPartsVals.C1)}`);
      } else {
        lines.push(`C1(shunt)：${fmtCap(lpPartsVals.C1)}`);
      }
    }
    if(lpPartsVals.C2 !== undefined) {
      if(wtype === 'LR2' || wtype === 'Butterworth' || wtype === 'Bessel') {
        lines.push(`C(shunt)：${fmtCap(lpPartsVals.C2)}`);
      } else {
        lines.push(`C2(shunt)：${fmtCap(lpPartsVals.C2)}`);
      }
    }
    if(lpPartsVals.L2 !== undefined) {
      if(wtype === 'LR2' || wtype === 'Butterworth' || wtype === 'Bessel') {
        lines.push(`L2(series)：${fmtInd(lpPartsVals.L2)}  （${lpPartsVals.note}）`);
      } else {
        lines.push(`L2(series)：${fmtInd(lpPartsVals.L2)}  （${lpPartsVals.note}）`);
      }
    }
    el('results').textContent = lines.join('\n');
  }
  ['show-woo','show-twe','show-sum','show-snapped','show-delta','show-imp'].forEach(function(id){ el(id).addEventListener('change', run); });
  el('calc').addEventListener('click', run);
  
  // Markdownエクスポート機能
  el('export-markdown').addEventListener('click', function() {
    const results = el('results').textContent;
    const timestamp = new Date().toLocaleString('ja-JP');
    
    // 結果を設計条件と計算結果に分割
    const parts = results.split('---');
    const designConditions = parts[0] || '';
    const calculationResults = parts.slice(1).join('---') || results;
    
    // 設計条件を整理（システム情報を抽出）
    const allLines = results.split('\n');
    const systemInfo = allLines.filter(line => 
      line.includes('システム：') || 
      line.includes('SPL基準:') || 
      line.includes('目標クロス周波数：') || 
      line.includes('HP（Tweeter）：') || 
      line.includes('LP（Woofer）：') || 
      line.includes('Zobel（Woofer補正）：') || 
      line.includes('L-pad（Tweeter減衰）：')
    );
    
    const markdown = `# スピーカーネットワーク設計結果

**生成日時:** ${timestamp}

## 設計条件
${systemInfo.join('\n')}

## 計算結果
${calculationResults}

---
*この結果は Speaker Network Calculator で生成されました*
*URL: ${window.location.href}*`;

    // ファイルダウンロード
    const blob = new Blob([markdown], { type: 'text/markdown;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `speaker-network-${Date.now()}.md`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  });
  
  // テストケース読み込み機能
  el('load-testcase').addEventListener('click', function() {
    // ユーザー提供のテストケース: 2-way, Woofer 8Ω/90dB, Tweeter 8Ω/98dB, Crossover 1800Hz, Tweeter LR4, Woofer LR2
    el('system').value = '2way';
    el('wz').value = '8';
    el('wspl').value = '90';
    el('tz').value = '8';
    el('tspl').value = '98';
    el('fc').value = '1800';
    el('wtype').value = 'LR2';
    el('ttype').value = 'LR4';
    el('spl-basis').value = 'minEfficiency';
    el('target-spl').value = '';
    el('wzobel').value = 'on';
    el('tlpad').value = 'auto';
    
    // 計算を実行
    run();
  });
  
  run();
</script>
</html>
